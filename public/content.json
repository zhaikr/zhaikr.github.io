{"meta":{"title":"JackRay的小博客","subtitle":null,"description":"儿时不知画中意，长大以是画中人","author":"JackRay","url":"http://yoursite.com"},"pages":[{"title":"自述","date":"2018-11-19T13:57:32.000Z","updated":"2018-11-21T14:03:51.684Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"##关于我正在上大学，学习图像识别、机器学习中。 email: 1119391474@qq.com"},{"title":"标签","date":"2018-11-19T13:57:50.000Z","updated":"2018-11-21T14:00:18.046Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"通过人脸识别来返回学号信息（一卡通）","slug":"通过人脸识别来返回学号信息（一卡通）","date":"2018-11-26T08:57:00.000Z","updated":"2018-11-26T10:12:44.972Z","comments":true,"path":"2018/11/26/通过人脸识别来返回学号信息（一卡通）/","link":"","permalink":"http://yoursite.com/2018/11/26/通过人脸识别来返回学号信息（一卡通）/","excerpt":"","text":"一.什么是人脸识别​ 人脸识别，是基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。 ​ 人脸识别系统主要包括四个组成部分，分别为：人脸图像采集及检测、人脸图像预处理、人脸图像特征提取以及匹配与识别。 二.相关库和配置环境​ 1.安装CMake ​ 如果你是Ubuntu用户就可以跳过你也可以选择升级CMake 123456789$ sudo apt-get install software-properties-common$ sudo add-apt-repository ppa:george-edison55/cmake-3.x$ sudo apt-get update#如果之前没有装CMake，执行$ sudo apt-get install cmake#如果之前已经装过CMake$ sudo apt-get upgrade#再次查看cmake的版本:$ cmake --version ​ 2.Dlib下载 ​ 这是Dlib的github网站https://github.com/davisking/dlib ​ ​ 箭头1就是clone地址如果你有GitHub可以输入以下代码(Ubuntu系统) ​ 1234$ mkdir Dlib$ cd Dlib$ git init$ git clone #复制clone地址 ​ 箭头2就是直接下载ZIP压缩包进行解压就好了 ​ 下好后进入Dlib文件 123$ cd Dlib$ python setup.py install#等待安装 ​ 3.安装 scikit-image 1$ pip install scikit-image ​ 三.开始人脸识别 ​ 这里，shape_predictor_68_face_landmarks.dat是已经训练好的人脸关键点检测器。 ​ dlib_face_recognition_resnet_model_v1.dat是训练好的ResNet人脸识别模型。 ​ 所有文件都可以在以下网址下载：http://dlib.net/files/。 ​ 其中all_faces文件夹是放我们学校所有人一卡通上的证件照 ​ 首先我们程序运行的思路是通过all_face_128D.py这个程序来先将所有证件照的描述子提取（128D向量）然后与照片文件的名字组成字典，最后将这个字典存入本地。这时我们就可以用face_rec.py来对证件照识别通过计算传入的人脸描述子与保存的字典中的描述子进行计算欧式距离。 ​ 以下是all_face_128D.py代码： 12345678910111213141516171819202122232425262728293031323334353637383940#coding=utf-8import sysimport dlibimport numpy as npimport osimport globfrom skimage import ioimport reimport jsoncurrent_path = os.getcwd() #获取当前路径predictor_path = current_path + '/model/shape_predictor_68_face_landmarks.dat' # 1.人脸关键点检测器face_rec_model_path = current_path + '/model/dlib_face_recognition_resnet_model_v1.dat' # 2.人脸识别模型face_folder_path = current_path + '/all_faces' # 3.所有人脸文件夹detector = dlib.get_frontal_face_detector() #加载正脸识别器shaper = dlib.shape_predictor(predictor_path) #加载人脸关键识别器facerec = dlib.face_recognition_model_v1(face_rec_model_path) #加载人脸模型all_face_d = &#123;&#125;for img_path in glob.glob(os.path.join(face_folder_path,\"*.jpg\")): print(\"processing file: &#123;&#125;\".format(img_path)) a = os.path.basename(img_path) b = re.compile('\\d+') filename = b.findall(a)[0] print(filename) img = io.imread(img_path) dets = detector(img,1) print(\"number of faces detected: &#123;&#125;\".format(len(dets))) for index, face in enumerate(dets): shape = shaper(img, face) # 2.关键点检测 # 3.描述子提取，128D向量 face_desciptor = facerec.compute_face_descriptor(img, shape) print(face_desciptor) vector = np.array(face_desciptor) #转换为numpy array all_face_d.setdefault(filename,vector)np.save('all_face_vectors.npy',all_face_d) 然后是face_rec.py的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#coding=utf-8import sysimport dlibimport numpy as npimport osimport globfrom skimage import ioimport base64current_path = os.getcwd() #获取当前路径predictor_path = current_path + '/model/shape_predictor_68_face_landmarks.dat' # 1.人脸关键点检测器face_rec_model_path = current_path + '/model/dlib_face_recognition_resnet_model_v1.dat' # 2.人脸识别模型face_folder_path = current_path + '/all_face' # 3.所有人脸文件夹imgs_path = io.imread('img/img.jpg') # 4.图片地址detector = dlib.get_frontal_face_detector() #加载正脸识别器shaper = dlib.shape_predictor(predictor_path) #加载人脸关键识别器facerec = dlib.face_recognition_model_v1(face_rec_model_path) #加载人脸模型 all_face_vectors = np.load('all_face_vectors.npy')data = all_face_vectors.item()def face_recognition(img_path): img = img_path dets = detector(img, 1) dist = &#123;&#125; for index, face in enumerate(dets): shape = shaper(img, face) # 2.关键点检测 # 3.描述子提取，128D向量 face_desciptor = facerec.compute_face_descriptor(img, shape) d_test = np.array(face_desciptor) #转换为numpy array for key,value in data.items(): dist_ = np.linalg.norm(value-d_test) dist.setdefault(key,dist_) cd_sorted = sorted(dist.items(), key=lambda d:d[1]) #print('\\n The person ID is: %s' % ( cd_sorted[0][0] ) ) return cd_sorted[0][0]if __name__ == '__main__': face_recognition(imgs_path) 以上就是所有代码和基本思路 我的GitHub上也有全部代码：https://github.com/zhaikr/face_recoginiton","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"dlib人脸识别库","slug":"dlib人脸识别库","permalink":"http://yoursite.com/tags/dlib人脸识别库/"}]},{"title":"一卡通识别（学校竞赛项目）","slug":"一卡通识别（学校竞赛项目）","date":"2018-11-23T11:02:00.000Z","updated":"2018-11-23T14:45:55.261Z","comments":true,"path":"2018/11/23/一卡通识别（学校竞赛项目）/","link":"","permalink":"http://yoursite.com/2018/11/23/一卡通识别（学校竞赛项目）/","excerpt":"","text":"因为在学校有人找到我一起去打比赛，那我就去了。我们做的是将我们学校的一卡通上的学号识别出来。 上图就是我们学校的一卡通要将学号给识别出来。 首先我的想法就是先找到特征点然后根据特征点的位置来确定学号的位置，然后再将学号给切割出来，这样的话就可以识别学号了。 首先我定义一个函数 如下： 1234567891011121314def shibie(img): image_arr = np.array(img)将图片变为矩阵 y_fd,x_fd = img.shape[:2]切出前两个参数 for y in range(y_fd): for x in range(x_fd): pj = image_arr[y,x] a = pj[0] b = pj[1] c = pj[2] if a &lt;= 1735 and a &gt;= 158: #调节参数 寻找特征点参数 if b &lt;= 185 and b &gt;= 175: if c &lt;= 105 and c &gt;= 90: y_list.append(y) x_list.append(x) 我的特征是根据图片的颜色通道来进行查找的，我找的特征点是学生卡那一块，因为那块的绿色比较容易找到不会出特别大的误差，就是有时候会不同设备拍摄出的照片的颜色(RBG)会不同导致参数可能不是特别准确，会匹配到其他位置去。 我又定义一个函数进行判断 如下： 12345678910111213141516def panduan(i,j,m,n,img): #获取特征区域x,y最大值和最小值 x_board = i-j y_board = m-n if x_board &gt; y_board: #判断图片的方向如果相反 进行图片旋转 img = Image.open(lujing) img = img.rotate(270, expand=True) img.save(lujing) img = plt.imread(lujing) x_list.clear y_list.clear shibie(img) xmax = max(x_list) xmin = min(x_list) ymax = max(y_list) ymin = min(y_list) return xmax,xmin,ymax,ymin 这里写了一个小小的判断，其中因为有的人拍照可能是横着拍，有的人是竖着拍的就会造成后面我们无法切割学号所以需要我们判断图片方向，然后我们要取出这个区域x,y的max,min。 最后就是执行程序，进行学号切割识别 如下： 123456789101112131415161718192021def xuehaoshibie(img): shibie(img) xmax = max(x_list) xmin = min(x_list) ymax = max(y_list) ymin = min(y_list) panduan(xmax,xmin,ymax,ymin,img) bili = (xmax-xmin)//365 #图片的矩阵比例 if bili == 0: bili = 1 y_tezheng = (ymax+ymin)//2 x_xhmax = xmin - 220*bili x_xhmin = xmin - 550*bili y_xhmin = ymin - 750*bili y_xhmax = y_tezheng im = img[y_xhmin:y_xhmax,x_xhmin:x_xhmax,:] shibiexuehao = pytesseract.image_to_string(im) b = re.compile('\\d+') data = b.findall(shibiexuehao)[0] print(data) return data 这里因为不同照片一卡通距离也会不同，但是一卡通这个本体不会改变我们只要找到一个比例然后根据比例来对将一卡通学号那一块区域切割下来。 这里我们首先根据特征区域的大小来确定比例，然后就在图像矩阵上查找就能切割图片。 最后用调用识别库来识别学号就行了。 我的github上也有完整代码：https://github.com/zhaikr/yikatongshibie","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"图像识别","slug":"图像识别","permalink":"http://yoursite.com/tags/图像识别/"},{"name":"pytesseract","slug":"pytesseract","permalink":"http://yoursite.com/tags/pytesseract/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-19T11:10:55.477Z","updated":"2018-11-19T08:25:28.146Z","comments":true,"path":"2018/11/19/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"在Ubuntu上向Github上传项目","slug":"Ubuntu GitHub上传项目","date":"2018-11-19T02:00:00.000Z","updated":"2018-11-21T07:49:03.282Z","comments":true,"path":"2018/11/19/Ubuntu GitHub上传项目/","link":"","permalink":"http://yoursite.com/2018/11/19/Ubuntu GitHub上传项目/","excerpt":"","text":"一.安装Git-LFS 当向github上传一些项目时会有一些提示 12$ remote: warning: Large files detected.$ remote: error: File giant_file is 123.00 MB; this exceeds GitHub's file size limit of 100 MB 这时候就需要检查一下自己的github版本 1$ git --version 如下图所示：之后安装Git-LFS打开终端 1.添加apt-get源 1$ curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash 2.安装Git-LFS 1$ sudo apt-get install git-lfs 3.初始化Git-LFS 1$ git lfs install Git-LFS就安装完成了 二.github官网进行账号注册 点击个人信息里的Settings 然后点击SSH and GPS keys 里面会有title 和 key 三.生成SSH秘钥 1.检查秘钥 1$ ls ~/.ssh/ 如果有秘钥进行备份 1$ mkdir key_backup 1$ cp ~/.ssh/id_* key_backup 2.生成ssh秘钥 12$ ssh-keygen -t rsa -C \"your_email@example.com\" #将your_email@example.com替换成你自己的邮箱 之后会有提示直接回车就行了 3.复制公钥 1$ cat ~/.ssh/id_rsa.pub 复制打开的内容到之前网站中的 key，title 可以随便填写 4.验证测试 1$ ssh -T git@github.com 执行后提示： 12345Hi github! You’ve successfully authenticated, but GitHub does not provide shell access. 此时设置用户名和邮箱为注册Github时的名字$ git config --global user.name “xxx”$ git config --global user.email xxx@gmail.com name就是你github的名字, email是你github的邮箱 四.创建远程仓库在github上 在此我创建一个名叫example的仓库，在repository name中输入example然后点击create repository 点击复制地址 五.建立本地仓库 12345678$ mkdir example #向文件夹中添加文件，加入仓库$ cd example$ git init 初始化仓库$ touch example.txt 创建一个txt文件$ git add . //.表示全添加 或者指定文件名 #提交到仓库，这个版本名字叫$ git commit -m \"first commit\" #\"first commit\"为备注可自行修改 六.提交本地代码到远程（同步） 123$ git remote add origin git@github.com:yourgithubname/yourrepositoryname #此时用之前复制的仓库url 替换“git@github.com:yourgithubname/yourrepositoryname”$ git push -u origin master 然后需要输入 name 和你账号的password 此时就上传成功 之后我们就可以检查远程仓库 我们上传文件成功","categories":[{"name":"github","slug":"github","permalink":"http://yoursite.com/categories/github/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]}]}